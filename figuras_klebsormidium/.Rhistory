data.fft <- fft(data.fou)
names(data.fft) <- NULL
wave.order <- order(waves[,2],decreasing = T)
x.n <- get.trajectory(data.fft,ts,acq.freq)
x.n <- x.n/max(Mod(x.n))
amp <- max(Mod(x.n)) - min(Mod(x.n))
plot(ts,x.n,type="l",lwd=2, ylim=c(0,1))
wave.colors <- c("red", "blue", "green", "purple", "orange", "gray")
fft.vector <- rep(0,length(data.fft))
for (j in n.waves)
{
#j<-1
fft.vector[wave.order[j]+1] <- data.fft[wave.order[j]+1]
fft.vector[length(ts)+2-(wave.order[j]+1)] <- data.fft[length(ts)+2-(wave.order[j]+1)]
}
fft.vector[1] <- data.fft[1]
harmonic.trajectory <- get.trajectory(fft.vector, ts, acq.freq=acq.freq)
harmonic.trajectory <- harmonic.trajectory/max(Mod(harmonic.trajectory))
points(ts, harmonic.trajectory, type="l",lty=2, col="darkred", lwd=3)
return(list(wave.params=waves, wave.points=data.fft,freqs.order=wave.order,comb.wave=harmonic.trajectory))
}
photo.and.skoto <- function(gene.name, genes.expression, sd.ll, sd.cycle)
{
fou <- genes.expression[gene.name,]
fousdll =fou[sd.ll]
wave.order <- wave.decomposition.scaled(as.numeric(fousdll), n.waves = 1:3, time=24, ts=seq(0,20,4))$freqs.order
order.pos <- which(wave.order == 1) #Extracts the wave with an associated period of 24h
dec.wave.ll <- wave.decomposition.scaled(as.numeric(fousdll), n.waves = order.pos, time=24, ts=seq(0,20,4))$comb.wave
foutot <- fou[sd.cycle]
dec.wave.ll.2 <- wave.decomposition.scaled(as.numeric(foutot), n.waves = 1:6, time=48, ts=seq(0,44,4))$comb.wave
dec.wave.res.cycle <- dec.wave.ll.2 - dec.wave.ll
ext.dec.wave.cycle.order <- wave.decomposition.scaled(as.numeric(dec.wave.res.cycle), n.waves = 1:6)$freqs.order
ord.pos <- which(ext.dec.wave.cycle.order == 2) #Extracts the wave with an associated period of 24h
ext.dec.wave.cycle <- wave.decomposition.scaled(as.numeric(dec.wave.res.cycle), n.waves = ord.pos)$comb.wave
ext.dec.wave.cycle <- ext.dec.wave.cycle + 1 #Makes all points positive
ext.dec.wave.cycle <- ext.dec.wave.cycle/max(Mod(ext.dec.wave.cycle))
dec.wave.ll <- dec.wave.ll - min(Mod(dec.wave.ll))
dec.wave.ll <- dec.wave.ll/max(Mod(dec.wave.ll))
dec.wave.ll.2 <- dec.wave.ll.2 - min(Mod(dec.wave.ll.2))
dec.wave.ll.2 <- dec.wave.ll.2/max(Mod(dec.wave.ll.2))
plot(seq(0,44,4), ext.dec.wave.cycle, type="l",lty=2, col="darkgrey", lwd=3, ylim=c(-0.2,1),
main=gene.name, ylab = "Normalized amplitude", xlab="Time")
points(seq(0,44,4), rep(dec.wave.ll,2), type="l",lty=2, col="darkorange", lwd=3)
points(seq(0,44,4), dec.wave.ll.2, type="l", col="black", lwd=3)
legend("bottomright", legend = c("photoperiod", "skotoperiod"), fill = c("darkorange","darkgrey"))
return(list(norm.wave = dec.wave.ll.2, norm.photo = dec.wave.ll, skoto.norm = ext.dec.wave.cycle))
}
result.fourier <- photo.and.skoto(gene.name=gene, genes.expression = gene.expression,
sd.ll= names(gene.expression.SD.LL)[1:6],
sd.cycle = names(gene.expression.SD)[1:12])
result.real <- wave.decomposition.scaled(data.fou = as.numeric(SD.DD),
n.waves= 1, time=48, acq.freq = 0.25,
ts=seq(0,44,4))
######Datos de marcos
#Function for extracting the strenght and frequency of the waves that compose the resulting one
#as calculated by GeneCycle
#circ.data <- as.numeric(fousdll)
library(GeneCycle)
library(stats)
extract.individual.waves <- function(circ.data) #n.samples must be even
{
perio <- periodogram(circ.data)
waves <- matrix(nrow = length(circ.data)/2, ncol = 2)
for (i in 1:length(circ.data)/2)
{
waves[i,1] <- perio$freq[i]*length(circ.data)
waves[i,2] <- perio$spec[i]
}
return(waves)
}
# Function for extracting the trajectory from fft output
get.trajectory <- function(X.k,ts,acq.freq) {
N   <- length(ts)
i   <- complex(real = 0, imaginary = 1)
x.n <- rep(0,N)           # create vector to keep the trajectory
ks  <- 0:(length(X.k)-1)
for(n in 0:(N-1)) {       # compute each time point x_n based on freqs X.k
x.n[n+1] <- sum(X.k * exp(i*2*pi*ks*n/N)) / N
}
x.n * acq.freq
}
#Function to draw each of the simple waves that make up the complex waveform
plot.harmonic <- function(Xk, i, ts, acq.freq, color="red") {
Xk.h <- rep(0,length(Xk))
Xk.h[i+1] <- Xk[i+1] # i-th harmonic
harmonic.trajectory <- get.trajectory(Xk.h, ts, acq.freq=acq.freq)
points(ts, harmonic.trajectory, type="l", col=color)
}
# Function for drawing the periodogram of a complex wave to determine the contribution
#of each wave to the complex pattern
draw.periodogram <- function(circ.data, harmonics=6)
{
period.data <- periodogram(circ.data)
plot(period.data$freq[1:harmonics]*length(circ.data),
period.data$spec[1:harmonics]/sum(period.data$spec),
xlab="Harmonics (Hz)", ylab="Amplitute Density", type="h")
}
###Más funciones
wave.decomposition.scaled <- function(data.fou, n.waves,time=48, acq.freq=0.25, ts=seq(0,44,4))
{
waves <- extract.individual.waves(data.fou)
colnames(waves) <- c("freq", "strength")
data.fft <- fft(data.fou)
names(data.fft) <- NULL
wave.order <- order(waves[,2],decreasing = T)
x.n <- get.trajectory(data.fft,ts,acq.freq)
x.n <- x.n/max(Mod(x.n))
amp <- max(Mod(x.n)) - min(Mod(x.n))
plot(ts,x.n,type="l",lwd=2, ylim=c(0,1))
wave.colors <- c("red", "blue", "green", "purple", "orange", "gray")
fft.vector <- rep(0,length(data.fft))
for (j in n.waves)
{
#j<-1
fft.vector[wave.order[j]+1] <- data.fft[wave.order[j]+1]
fft.vector[length(ts)+2-(wave.order[j]+1)] <- data.fft[length(ts)+2-(wave.order[j]+1)]
}
fft.vector[1] <- data.fft[1]
harmonic.trajectory <- get.trajectory(fft.vector, ts, acq.freq=acq.freq)
harmonic.trajectory <- harmonic.trajectory/max(Mod(harmonic.trajectory))
points(ts, harmonic.trajectory, type="l",lty=2, col="darkred", lwd=3)
return(list(wave.params=waves, wave.points=data.fft,freqs.order=wave.order,comb.wave=harmonic.trajectory))
}
photo.and.skoto <- function(gene.name, genes.expression, sd.ll, sd.cycle)
{
fou <- genes.expression[gene.name,]
fousdll =fou[sd.ll]
wave.order <- wave.decomposition.scaled(as.numeric(fousdll), n.waves = 1:3, time=24, ts=seq(0,20,4))$freqs.order
order.pos <- which(wave.order == 1) #Extracts the wave with an associated period of 24h
dec.wave.ll <- wave.decomposition.scaled(as.numeric(fousdll), n.waves = order.pos, time=24, ts=seq(0,20,4))$comb.wave
foutot <- fou[sd.cycle]
dec.wave.ll.2 <- wave.decomposition.scaled(as.numeric(foutot), n.waves = 1:6, time=48, ts=seq(0,44,4))$comb.wave
dec.wave.res.cycle <- dec.wave.ll.2 - dec.wave.ll
ext.dec.wave.cycle.order <- wave.decomposition.scaled(as.numeric(dec.wave.res.cycle), n.waves = 1:6)$freqs.order
ord.pos <- which(ext.dec.wave.cycle.order == 2) #Extracts the wave with an associated period of 24h
ext.dec.wave.cycle <- wave.decomposition.scaled(as.numeric(dec.wave.res.cycle), n.waves = ord.pos)$comb.wave
ext.dec.wave.cycle <- ext.dec.wave.cycle + 1 #Makes all points positive
ext.dec.wave.cycle <- ext.dec.wave.cycle/max(Mod(ext.dec.wave.cycle))
dec.wave.ll <- dec.wave.ll - min(Mod(dec.wave.ll))
dec.wave.ll <- dec.wave.ll/max(Mod(dec.wave.ll))
dec.wave.ll.2 <- dec.wave.ll.2 - min(Mod(dec.wave.ll.2))
dec.wave.ll.2 <- dec.wave.ll.2/max(Mod(dec.wave.ll.2))
plot(seq(0,44,4), ext.dec.wave.cycle, type="l",lty=2, col="darkgrey", lwd=3, ylim=c(-0.2,1),
main=gene.name, ylab = "Normalized amplitude", xlab="Time")
points(seq(0,44,4), rep(dec.wave.ll,2), type="l",lty=2, col="darkorange", lwd=3)
points(seq(0,44,4), dec.wave.ll.2, type="l", col="black", lwd=3)
legend("bottomright", legend = c("photoperiod", "skotoperiod"), fill = c("darkorange","darkgrey"))
return(list(norm.wave = dec.wave.ll.2, norm.photo = dec.wave.ll, skoto.norm = ext.dec.wave.cycle))
}
result.fourier <- photo.and.skoto(gene.name=gene, genes.expression = gene.expression,
sd.ll= names(gene.expression.SD.LL)[1:6],
sd.cycle = names(gene.expression.SD)[1:12])
result.real <- wave.decomposition.scaled(data.fou = as.numeric(SD.DD),
n.waves= 1, time=48, acq.freq = 0.25,
ts=seq(0,44,4))
#onda a partir de la real
result.real <- wave.decomposition.scaled(data.fou = as.numeric(SD.DD),
n.waves= 1, time=48, acq.freq = 0.25,
ts=seq(0,44,4))
result.real
fourier.DD <- result.fourier$skoto.norm
fourier.DD <- matrix(ncol=12, nrow=1,as.numeric(Mod(result.fourier$skoto.norm)))
colnames(fourier.DD) <- names(SD.DD)
rownames(fourier.DD) <- gene
#onda a partir de la real
result.real <- wave.decomposition.scaled(data.fou = as.numeric(SD.DD),
n.waves= 2, time=48, acq.freq = 0.25,
ts=seq(0,44,4))
#onda a partir de la real
result.real <- wave.decomposition.scaled(data.fou = as.numeric(SD.DD),
n.waves= 1, time=48, acq.freq = 0.25,
ts=seq(0,44,4))
fourier.DD <- result.fourier$skoto.norm
fourier.DD <- matrix(ncol=12, nrow=1,as.numeric(Mod(result.fourier$skoto.norm)))
colnames(fourier.DD) <- names(SD.DD)
rownames(fourier.DD) <- gene
real.DD <- Mod(result.real$wave.points) - min(Mod(result.real$wave.points))
real.DD <- real.DD/max(real.DD)
real.DD <- matrix(ncol=12, nrow=1,real.DD)
colnames(real.DD) <- names(SD.DD)
rownames(real.DD) <- gene
circacompare.DD.fou <- matrix(ncol=1,nrow=15)
gene <- gene
circacomp.data <- data.frame(time=c(time.points,time.points),
measure=c(t(fourier.DD/max(fourier.DD)),
t(real.DD/max(real.DD))),
group=c(rep("DD_fou",12),rep("DD_SD",12)))
fourier.DD
SD.LL <-gene.expression.SD.LL[gene,]
LD.LL <-gene.expression.LD.LL[gene,]
LD.LL
LD.LL/max(LD.LL)
fourier.DD
fourier.DD/max(fourier.DD)
real.DD[10]
fourier.DD[10]
fourier.DD[10]<-0.99
fourier.DD
real.DD
real.DD[8]
real.DD[8]<-0.00000000000000000000000001
real.DD
circacomp.data <- data.frame(time=c(time.points,time.points),
measure=c(t(fourier.DD),
t(real.DD)),
group=c(rep("DD_fou",12),rep("DD_SD",12)))
result.i<- circacompare(x = circacomp.data,
col_time = "time",
col_group = "group",
col_outcome = "measure",
alpha_threshold = 1)
result.i
gene <- "ostta03g03470"
gene <- genes[i]
SD.LL <-gene.expression.SD.LL[gene,]
LD.LL <-gene.expression.LD.LL[gene,]
SD.DD <-gene.expression.SD.DD[gene,]
LD.DD <-gene.expression.LD.DD[gene,]
gene <- "ostta03g03470"
#onda marcos
result.fourier <- photo.and.skoto(gene.name=gene, genes.expression = gene.expression,
sd.ll= names(gene.expression.SD.LL)[1:6],
sd.cycle = names(gene.expression.SD)[1:12])
#onda a partir de la real
result.real <- wave.decomposition.scaled(data.fou = as.numeric(SD.DD),
n.waves= 1, time=48, acq.freq = 0.25,
ts=seq(0,44,4))
fourier.DD <- result.fourier$skoto.norm
fourier.DD <- matrix(ncol=12, nrow=1,as.numeric(Mod(result.fourier$skoto.norm)))
colnames(fourier.DD) <- names(SD.DD)
rownames(fourier.DD) <- gene
real.DD <- Mod(result.real$wave.points) - min(Mod(result.real$wave.points))
real.DD <- real.DD/max(real.DD)
real.DD <- matrix(ncol=12, nrow=1,real.DD)
colnames(real.DD) <- names(SD.DD)
rownames(real.DD) <- gene
#para cicacompare no puede haber dos 1 ni llegar ningun dato a 0.
fourier.DD[10]<-0.99
fourier.DD <- result.fourier$skoto.norm
fourier.DD <- matrix(ncol=12, nrow=1,as.numeric(Mod(result.fourier$skoto.norm)))
colnames(fourier.DD) <- names(SD.DD)
rownames(fourier.DD) <- gene
real.DD <- Mod(result.real$wave.points) - min(Mod(result.real$wave.points))
real.DD <- real.DD/max(real.DD)
real.DD <- matrix(ncol=12, nrow=1,real.DD)
colnames(real.DD) <- names(SD.DD)
rownames(real.DD) <- gene
fourier.DD
#para cicacompare no puede haber dos 1 ni llegar ningun dato a 0.
fourier.DD[10]<-0.99
real.DD
#real.DD[8]<-0.00000000000000000000000001
circacompare.DD.fou <- matrix(ncol=1,nrow=15)
gene <- gene
circacomp.data <- data.frame(time=c(time.points,time.points),
measure=c(t(fourier.DD),
t(real.DD)),
group=c(rep("DD_fou",12),rep("DD_SD",12)))
result.i<- circacompare(x = circacomp.data,
col_time = "time",
col_group = "group",
col_outcome = "measure",
alpha_threshold = 1)
circacompare.DD.DD[i,] <- result.i$summary[,2]
rownames(circacompare.DD.DD) <- as.character(genes)
colnames(circacompare.DD.DD) <- result.i[[2]][,1]
SD.DD <-gene.expression.SD.DD[gene,]
LD.DD <-gene.expression.LD.DD[gene,]
circacompare.DD.DD
result.i<- circacompare(x = circacomp.data,
col_time = "time",
col_group = "group",
col_outcome = "measure",
alpha_threshold = 1)
circacompare.DD.DD[i,] <- result.i$summary[,2]
result.i<- circacompare(x = circacomp.data,
col_time = "time",
col_group = "group",
col_outcome = "measure",
alpha_threshold = 1)
result.i
result.fourier
fourier.LL <- result.fourier$norm.photo
fourier.LL<- matrix(ncol=12, nrow=1,as.numeric(Mod(result.fourier$norm.wave)))
colnames(fourier.LL) <- names(SD.DD)
rownames(fourier.LL) <- gene
fourier.LL
result.real <- wave.decomposition.scaled(data.fou = as.numeric(SD.DD),
n.waves= 1, time=48, acq.freq = 0.25,
ts=seq(0,44,4))
result.real.LL <- wave.decomposition.scaled(data.fou = as.numeric(SD.DD),
n.waves= 1, time=48, acq.freq = 0.25,
ts=seq(0,44,4))
real.LL <- Mod(result.real$wave.points) - min(Mod(result.real$wave.points))
real.LL <- Mod(result.real.LL$wave.points) - min(Mod(result.real.LL$wave.points))
real.LL <- real.DD/max(real.LL)
real.LL <- matrix(ncol=12, nrow=1,real.LL)
result.real.LL <- wave.decomposition.scaled(data.fou = as.numeric(SD.LL),
n.waves= 1, time=48, acq.freq = 0.25,
ts=seq(0,44,4))
real.LL <- Mod(result.real.LL$wave.points) - min(Mod(result.real.LL$wave.points))
real.LL <- real.DD/max(real.LL)
real.LL <- matrix(ncol=12, nrow=1,real.LL)
colnames(real.LL) <- names(SD.LL)
rownames(real.LL) <- gene
real.LL
fourier.LL
circacomp.data <- data.frame(time=c(time.points,time.points),
measure=c(t(fourier.LL)),
t(real.LL)),
group=c(rep("LL_fou",12),rep("LL_SD",12)))
circacompare.DD.fou <- matrix(ncol=1,nrow=15)
circacompare.LL.fou <- matrix(ncol=1,nrow=15)
circacomp.data <- data.frame(time=c(time.points,time.points),
measure=c(t(fourier.LL),
t(real.LL)),
group=c(rep("LL_fou",12),rep("LL_SD",12)))
result.i<- circacompare(x = circacomp.data,
col_time = "time",
col_group = "group",
col_outcome = "measure",
alpha_threshold = 1,timeout_n = 20000)
circacompare
result.i
real.LL
result.real.LL <- wave.decomposition.scaled(data.fou = as.numeric(SD.LL),
n.waves= 1, time=48, acq.freq = 0.25,
ts=seq(0,44,4))
real.LL <- Mod(result.real.LL$wave.points) - min(Mod(result.real.LL$wave.points))
real.LL <- real.LL/max(real.LL)
real.LL <- matrix(ncol=12, nrow=1,real.LL)
colnames(real.LL) <- names(SD.LL)
rownames(real.LL) <- gene
circacompare.LL.fou <- matrix(ncol=1,nrow=15)
circacomp.data <- data.frame(time=c(time.points,time.points),
measure=c(t(fourier.LL),
t(real.LL)),
group=c(rep("LL_fou",12),rep("LL_SD",12)))
result.i<- circacompare(x = circacomp.data,
col_time = "time",
col_group = "group",
col_outcome = "measure",
alpha_threshold = 1,timeout_n = 20000)
result.i
runApp('~/Documentos/GitHub/osttaCIRC')
setwd("~/Documentos/GitHub/test_scripts/figuras_klebsormidium")
## Load and preprocess metabolomic data from first run
raw.metabolomic.data.1 <- read.table(file="klebso_metabolomic_data_1.tsv",header=T,sep="\t",as.is=T)
setwd("~/Documentos/GitHub/test_scripts/figuras_klebsormidium")
## Load and preprocess metabolomic data from first run
raw.metabolomic.data.1 <- read.table(file="klebso_metabolomic_data_1.tsv",header=T,sep="\t",as.is=T)
## Carotenoids
carotenoids <- read.table(file="../carotenoids/carotenoids_klebsormidium.tsv",header=T,sep="\t",as.is=T)
gene.expression <- read.table(file = "gene_expression_kleb.tsv", header=T, as.is=T)
gene.expression.HL <- (gene.expression[,"HL_1"] + gene.expression[,"HL_2"])/2
names(gene.expression.HL) <- gene.expression$geneID
mean.expression.HL <- (gene.expression[,"HL_1"] + gene.expression[,"HL_2"])/2
names(mean.expression.HL) <- gene.expression$geneID
mean.expression.LL <- (gene.expression[,"LL_1"] + gene.expression[,"LL_2"])/2
names(mean.expression.LL) <- gene.expression$geneID
heatmap.enzyme.id <- function(gene.id,enzyme.name,gene.expression,precision)
{
pos.colfunc <- colorRampPalette(c("white","gold"))
pos.colors <- pos.colfunc(precision)
neg.colfunc <- colorRampPalette(c("white","lightslateblue"))
neg.colors <- neg.colfunc(precision)
fc.max <- 0
fc.min <- 20
enzyme.mean.HL <- mean.expression.HL[gene.id]
enzyme.mean.LL <- mean.expression.LL[gene.id]
fc <- enzyme.mean.HL/enzyme.mean.LL
if(fc >= 1)
{
if(fc >= fc.max)
{
fc.max <- fc
}
if(round(fc*10) < precision)
{
cols <- pos.colors[round(fc*10)]
} else
{
cols <- pos.colors[precision]
}
} else
{
if(fc <= fc.min)
{
fc.min <- fc
}
if(round(10/fc) < precision)
{
cols <- neg.colors[round(10/fc)]
} else
{
cols <- neg.colors[precision]
}
}
plot<-plot(x=0,y=0,col="white",
axes=F,xlab="",ylab="",
ylim=c(0,10),xlim=c(0,10))
plot<-polygon(x = c(2,8,8,2),y=c(2,2,8,8),lwd=6,col = cols)
return(plot)
}
colfunc<-colorRampPalette(c("lightslateblue","white","orange2"))
plot(rep(1,1000),col=(colfunc(1000)), pch=15,cex=20,xlim=c(0,730),axes=F,
ylab="",xlab="")
hist(circacompare.LL.LL[,13])
mean(circacompare.LL.LL[,13])
hist(circacompare.DD.DD[,13])
mean(circacompare.DD.DD[,13])
######para DD
#onda marcos
result.fourier <- photo.and.skoto(gene.name=gene, genes.expression = gene.expression,
sd.ll= names(gene.expression.SD.LL)[1:6],
sd.cycle = names(gene.expression.SD)[1:12])
gene <- "ostta03g03470"
extract.individual.waves <- function(circ.data) #n.samples must be even
{
perio <- periodogram(circ.data)
waves <- matrix(nrow = length(circ.data)/2, ncol = 2)
for (i in 1:length(circ.data)/2)
{
waves[i,1] <- perio$freq[i]*length(circ.data)
waves[i,2] <- perio$spec[i]
}
return(waves)
}
# Function for extracting the trajectory from fft output
get.trajectory <- function(X.k,ts,acq.freq) {
N   <- length(ts)
i   <- complex(real = 0, imaginary = 1)
x.n <- rep(0,N)           # create vector to keep the trajectory
ks  <- 0:(length(X.k)-1)
for(n in 0:(N-1)) {       # compute each time point x_n based on freqs X.k
x.n[n+1] <- sum(X.k * exp(i*2*pi*ks*n/N)) / N
}
x.n * acq.freq
}
#Function to draw each of the simple waves that make up the complex waveform
plot.harmonic <- function(Xk, i, ts, acq.freq, color="red") {
Xk.h <- rep(0,length(Xk))
Xk.h[i+1] <- Xk[i+1] # i-th harmonic
harmonic.trajectory <- get.trajectory(Xk.h, ts, acq.freq=acq.freq)
points(ts, harmonic.trajectory, type="l", col=color)
}
# Function for drawing the periodogram of a complex wave to determine the contribution
#of each wave to the complex pattern
draw.periodogram <- function(circ.data, harmonics=6)
{
period.data <- periodogram(circ.data)
plot(period.data$freq[1:harmonics]*length(circ.data),
period.data$spec[1:harmonics]/sum(period.data$spec),
xlab="Harmonics (Hz)", ylab="Amplitute Density", type="h")
}
###Más funciones
wave.decomposition.scaled <- function(data.fou, n.waves,time=48, acq.freq=0.25, ts=seq(0,44,4))
{
waves <- extract.individual.waves(data.fou)
colnames(waves) <- c("freq", "strength")
data.fft <- fft(data.fou)
names(data.fft) <- NULL
wave.order <- order(waves[,2],decreasing = T)
x.n <- get.trajectory(data.fft,ts,acq.freq)
x.n <- x.n/max(Mod(x.n))
amp <- max(Mod(x.n)) - min(Mod(x.n))
plot(ts,x.n,type="l",lwd=2, ylim=c(0,1))
wave.colors <- c("red", "blue", "green", "purple", "orange", "gray")
fft.vector <- rep(0,length(data.fft))
for (j in n.waves)
{
#j<-1
fft.vector[wave.order[j]+1] <- data.fft[wave.order[j]+1]
fft.vector[length(ts)+2-(wave.order[j]+1)] <- data.fft[length(ts)+2-(wave.order[j]+1)]
}
fft.vector[1] <- data.fft[1]
harmonic.trajectory <- get.trajectory(fft.vector, ts, acq.freq=acq.freq)
harmonic.trajectory <- harmonic.trajectory/max(Mod(harmonic.trajectory))
points(ts, harmonic.trajectory, type="l",lty=2, col="darkred", lwd=3)
return(list(wave.params=waves, wave.points=data.fft,freqs.order=wave.order,comb.wave=harmonic.trajectory))
}
photo.and.skoto <- function(gene.name, genes.expression, sd.ll, sd.cycle)
{
fou <- genes.expression[gene.name,]
fousdll =fou[sd.ll]
wave.order <- wave.decomposition.scaled(as.numeric(fousdll), n.waves = 1:3, time=24, ts=seq(0,20,4))$freqs.order
order.pos <- which(wave.order == 1) #Extracts the wave with an associated period of 24h
dec.wave.ll <- wave.decomposition.scaled(as.numeric(fousdll), n.waves = order.pos, time=24, ts=seq(0,20,4))$comb.wave
foutot <- fou[sd.cycle]
dec.wave.ll.2 <- wave.decomposition.scaled(as.numeric(foutot), n.waves = 1:6, time=48, ts=seq(0,44,4))$comb.wave
dec.wave.res.cycle <- dec.wave.ll.2 - dec.wave.ll
ext.dec.wave.cycle.order <- wave.decomposition.scaled(as.numeric(dec.wave.res.cycle), n.waves = 1:6)$freqs.order
ord.pos <- which(ext.dec.wave.cycle.order == 2) #Extracts the wave with an associated period of 24h
ext.dec.wave.cycle <- wave.decomposition.scaled(as.numeric(dec.wave.res.cycle), n.waves = ord.pos)$comb.wave
ext.dec.wave.cycle <- ext.dec.wave.cycle + 1 #Makes all points positive
ext.dec.wave.cycle <- ext.dec.wave.cycle/max(Mod(ext.dec.wave.cycle))
dec.wave.ll <- dec.wave.ll - min(Mod(dec.wave.ll))
dec.wave.ll <- dec.wave.ll/max(Mod(dec.wave.ll))
dec.wave.ll.2 <- dec.wave.ll.2 - min(Mod(dec.wave.ll.2))
dec.wave.ll.2 <- dec.wave.ll.2/max(Mod(dec.wave.ll.2))
plot(seq(0,44,4), ext.dec.wave.cycle, type="l",lty=2, col="darkgrey", lwd=3, ylim=c(-0.2,1),
main=gene.name, ylab = "Normalized amplitude", xlab="Time")
points(seq(0,44,4), rep(dec.wave.ll,2), type="l",lty=2, col="darkorange", lwd=3)
points(seq(0,44,4), dec.wave.ll.2, type="l", col="black", lwd=3)
legend("bottomright", legend = c("photoperiod", "skotoperiod"), fill = c("darkorange","darkgrey"))
return(list(norm.wave = dec.wave.ll.2, norm.photo = dec.wave.ll, skoto.norm = ext.dec.wave.cycle))
}
######para DD
#onda marcos
result.fourier <- photo.and.skoto(gene.name=gene, genes.expression = gene.expression,
sd.ll= names(gene.expression.SD.LL)[1:6],
sd.cycle = names(gene.expression.SD)[1:12])
